namespace Main;

struct Int {
    value: int;

    constructor(val: int) {
        this.value = val;
    }

    toString() -> string {
        return intToString(this.value);
    }

    fooMethod() -> void {
        printStr("Foo method called");
        return;
    }
}


function stringTesting() -> void {
    printStr("------- String Testing --------");

    const testString: string = "Hello";

    // const indexStringOne: string = testString[0];
    // const indexStringTwo: string = testString[1];
    // const indexStringThree: string = testString[2];
    
    // printStr(indexStringOne);
    // printStr(indexStringTwo);
    // printStr(indexStringThree);

    // printStr(testString[0]);

    return;
}

function arrayTesting() -> void {
    printStr("--------- Array Testing ---------");
    const fooArr: int[] = [1, 2, 3, 4, 5];
    
    printInt(fooArr[0]);
    printInt(fooArr[1]);
    printInt(fooArr[2]);
    printInt(fooArr[3]);
    printInt(fooArr[4]);

    // This should throw an error and calls `sys_exit()` (for now).
    // Eventually, I'll just return null and move on with execution.
    // printInt(fooArr[5]);

    return;
}


function structTesting() -> void {
    printStr("-------- Struct Testing --------");
    const intTest: Int = 1234;
    const intTestTwo: int = intTest.value;
    printInt(intTestTwo);
    printInt(intTest.value);

    const strVal: string = intTest.toString();
    printStr(strVal);
    printStr(intTest.toString());

    intTest.fooMethod();

    return;
}


function binOpTest() -> void {
    printStr("------ Binary Ops Testing ------");
    const addTest: int = 34 + 36;
    printStr("Addition test: ");
    printInt(addTest);
    
    const subTest: int = 36 - 34;
    printStr("Subtraction test: ");
    printInt(subTest);

    const mulTest: int = 16 * 16;
    printStr("Multiplication test: ");
    printInt(mulTest);

    const divTest: int = 10 / 2;
    printStr("Division test: ");
    printInt(divTest);

    const modTest: int = 10 % 3;
    printStr("Modulus test: ");
    printInt(modTest);

    return;
}


function main(argc: int, argv: string[]) -> void {
    printStr("-------- Main Function --------");
    printStr("Arg count: ");
    printInt(argc);

    printStr("\nArgv[0]:");
    const argOne: string = argv[0];
    printStr(argOne);

    structTesting();
    binOpTest();
    arrayTesting();
    // stringTesting();
    objectTesting();

    return;
}

// function matchTesting() -> void {
//     const intStructTest: Int = 999;
// 
//     match (intStructTest) {
//         case Int -> {
//             printStr("Matched Int");
//         }
//         case _  -> {
//             printStr("Matched default");
//         }
//     }
// }

// 
// function arrayTesting() -> void {
//     const intArray: Array<Int> = [1, 2, 3, 4, 5];
// }

// I need to figure out how to make two types of enums.
// 1. Simple enums that are just a list of values (like in C)
// 2. Enums that are a list of values with associated data (like in Rust)

// enum TestEnum {
//     Foo,
//     Bar,
//     Baz,
//     Buz
// }

// enum TestEnumTwo {
//     Foo(int),
//     Bar(string),
//     Baz(Int),
//     Buz(Int)
// }

// function testEnums() -> void {
//     const testEnum: TestEnum = TestEnum::Foo;
//     const testEnumTwo: TestEnumTwo = TestEnumTwo::Foo(1234);

//     match (testEnum) {
//         case TestEnum::Foo -> {
//             printStr("Matched Foo");
//         }
//         case TestEnum::Bar -> {
//             printStr("Matched Bar");
//         }
//         case TestEnum::Baz -> {
//             printStr("Matched Baz");
//         }
//         case TestEnum::Buz -> {
//             printStr("Matched Buz");
//         }
//     }

//     match (testEnumTwo) {
//         case TestEnumTwo::Foo(val) -> {
//             printStr("Matched Foo");
//             printInt(val);
//         }
//         case TestEnumTwo::Bar(val) -> {
//             printStr("Matched Bar");
//             printStr(val);
//         }
//         case TestEnumTwo::Baz(val) -> {
//             printStr("Matched Baz");
//             printInt(val.value);
//         }
//         case TestEnumTwo::Buz(val) -> {
//             printStr("Matched Buz");
//             printInt(val.value);
//         }
//     }
// }
